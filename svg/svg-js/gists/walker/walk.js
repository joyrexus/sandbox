// Generated by CoffeeScript 1.6.3
(function() {
  var DELTA, bug, crossover, cursor, d, direction, draw, drawBlock, edge, frameStyle, h, jumpTo, moveTo, step, trail, w, walk;

  d = 20;

  w = 900;

  h = 500;

  step = 250;

  edge = {
    north: 0,
    south: h - d,
    east: w - d,
    west: 0
  };

  frameStyle = {
    fill: "none",
    stroke: "#555"
  };

  draw = SVG('canvas').size(w, h);

  draw.rect(w, h).attr(frameStyle);

  drawBlock = function() {
    return draw.rect(d, d);
  };

  cursor = function(x, y) {
    return drawBlock().fill("steelblue").move(x, y);
  };

  trail = function(x, y) {
    return drawBlock().fill("#999").move(x, y).back();
  };

  direction = function() {
    switch (Math.floor(Math.random() * 4)) {
      case 0:
        return 'N';
      case 1:
        return 'S';
      case 2:
        return 'E';
      case 3:
        return 'W';
    }
  };

  DELTA = {
    N: {
      x: 0,
      y: d
    },
    S: {
      x: 0,
      y: -d
    },
    E: {
      x: d,
      y: 0
    },
    W: {
      x: -d,
      y: 0
    }
  };

  bug = cursor(w / 2 - d / 2, h / 2 - d / 2);

  moveTo = function(next) {
    return bug.front().animate(step).move(next.x, next.y);
  };

  jumpTo = function(jump) {
    return function() {
      return bug.move(jump.x, jump.y);
    };
  };

  crossover = function(next, jump) {
    return moveTo(next).after(jumpTo(jump));
  };

  walk = function(trailing) {
    var D, jump, next, x, y;
    if (trailing == null) {
      trailing = true;
    }
    x = bug.x();
    y = bug.y();
    if (trailing) {
      trail(x, y);
    }
    D = DELTA[direction()];
    next = {
      x: x + D.x,
      y: y + D.y
    };
    jump = {
      x: x,
      y: y
    };
    if (D.x) {
      if (next.x > edge.east) {
        jump.x = edge.west;
        return crossover(next, jump);
      } else if (next.x < edge.west) {
        jump.x = edge.east;
        return crossover(next, jump);
      } else {
        return moveTo(next);
      }
    } else {
      if (next.y > edge.south) {
        jump.y = edge.north;
        return crossover(next, jump);
      } else if (next.y < edge.north) {
        jump.y = edge.south;
        return crossover(next, jump);
      } else {
        return moveTo(next);
      }
    }
  };

  setInterval(walk, step * 2);

}).call(this);
